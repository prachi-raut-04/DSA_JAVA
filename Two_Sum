// Brute force apporach

class Solution {
    public static int[] twoSum(int[] nums, int target) {
        int n = nums.length;

        for(int i=0; i<n; i++) {
          for(int j=i+1; j<n; j++) {
              if(nums[i] + nums[j] == target)  {
                  return new int[] {i, j};
              }
          }
          return new int[] {-1, -1};
      }
    }
}

Time complexity : O(nÂ²)
Space Complexity : O(1)

// Using Binary Search Approach

// Optimized apporach 

class Solution {
    public static int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        HashMap<Integer, Integer> map = new HashMap<>();

        for(int i=0; i<n; i++) {
            int temp = target - nums[i];
            if(map.containsKey(temp)) {
                return new int[] {map.get(temp), i};
            } 
            map.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}

Time complexity : O(n)
Space complexity : O(n)
