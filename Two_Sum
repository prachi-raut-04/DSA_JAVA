// Brute Force Apporach

class Solution {
    public static int[] twoSum(int[] nums, int target) {
        int n = nums.length;

        for(int i=0; i<n; i++) {
          for(int j=i+1; j<n; j++) {
              if(nums[i] + nums[j] == target)  {
                  return new int[] {i, j};
              }
          }
          return new int[] {-1, -1};
      }
    }
}

Time complexity : O(nÂ²)
Space Complexity : O(1)

// Using Binary Search Approach

class Solution {
    static class Pair implements Comparable<Pair> {
        int val;
        int idx;

        public Pair(int val, int idx) {
            this.val = val;
            this.idx = idx;
        }

        @Override
        public int compareTo(Pair p2) {
            return this.val - p2.val;
        }
    }

    public static int[] twoSum(int[] nums, int target) {
        Pair pairs[] = new Pair[nums.length];

        for(int i=0; i<nums.length; i++) {
            pairs[i] = new Pair(nums[i], i);
        }

        Arrays.sort(pairs);
        int l = 0;
        int r = nums.length - 1;
        while(l < r) {
            if(pairs[l].val + pairs[r].val == target) {
                return new int[] {pairs[l].idx, pairs[r].idx};
            } else if(pairs[l].val + pairs[r].val > target) {
                r--;
            } else {
                l++;
            }
        }

        return new int[] {-1, -1};
    }
}

Time Complexity : O(n log n)
Space Complexity : O(n)

// Optimized Apporach 

class Solution {
    public static int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        HashMap<Integer, Integer> map = new HashMap<>();

        for(int i=0; i<n; i++) {
            int temp = target - nums[i];
            if(map.containsKey(temp)) {
                return new int[] {map.get(temp), i};
            } 
            map.put(nums[i], i);
        }
        return new int[] {-1, -1};
    }
}

Time complexity : O(n)
Space complexity : O(n)
