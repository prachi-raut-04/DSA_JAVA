Approach 1

public class Solution {
    public int length(ListNode node) {
        int len = 0;

        while(node != null) {
            len++;
            node = node.next;
        }

        return len;
    }

    public ListNode changePos(ListNode node, int sz) {
        for(int i=0; i<sz; i++) {
            node = node.next;
        }

        return node;
    }

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int l1 = length(headA);
        int l2 = length(headB);
        ListNode temp1 = headA;
        ListNode temp2 = headB;

        if(l1 > l2) {
            temp1 = changePos(headA, l1-l2);
        } else if(l1 < l2) {
            temp2 = changePos(headB, l2-l1);
        }

        while(temp1 != null) {
            if(temp1 == temp2) {
                return temp1;
            }
            temp1 = temp1.next;
            temp2 = temp2.next;
        }

        return null;
    }
}

Time Compelxity : O(m+n)
Space complexity : O(1)

Approach 2


public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA, b = headB;
        while (a != b) {
            a = (a == null) ? headB : a.next;
            b = (b == null) ? headA : b.next;
        }
        return a; 
    }
}

Time Complexity : O()
